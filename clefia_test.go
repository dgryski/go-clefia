package clefia

import (
	"bytes"
	"testing"
)

// via https://www.rfc-editor.org/rfc/rfc6114.txt
var tests = []struct {
	key    []byte
	plain  []byte
	cipher []byte
}{
	{

		[]byte{0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00},
		[]byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f},
		[]byte{0xde, 0x2b, 0xf2, 0xfd, 0x9b, 0x74, 0xaa, 0xcd, 0xf1, 0x29, 0x85, 0x55, 0x45, 0x94, 0x94, 0xfd},
	},

	{

		[]byte{0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00, 0xf0, 0xe0, 0xd0, 0xc0, 0xb0, 0xa0, 0x90, 0x80},
		[]byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f},
		[]byte{0xe2, 0x48, 0x2f, 0x64, 0x9f, 0x02, 0x8d, 0xc4, 0x80, 0xdd, 0xa1, 0x84, 0xfd, 0xe1, 0x81, 0xad},
	},

	{
		[]byte{0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00, 0xf0, 0xe0, 0xd0, 0xc0, 0xb0, 0xa0, 0x90, 0x80, 0x70, 0x60, 0x50, 0x40, 0x30, 0x20, 0x10, 0x00},
		[]byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f},
		[]byte{0xa1, 0x39, 0x78, 0x14, 0x28, 0x9d, 0xe8, 0x0c, 0x10, 0xda, 0x46, 0xd1, 0xfa, 0x48, 0xb3, 0x8a},
	},
}

func TestClefia(t *testing.T) {

	for _, tst := range tests {

		var cl clefiaCipher
		r := clefiaKeySet(cl.rk[:], tst.key, len(tst.key)*8)
		var ct [16]byte
		clefiaEncrypt(ct[:], tst.plain[:], cl.rk[:], r)

		if !bytes.Equal(ct[:], tst.cipher) {
			t.Errorf("encrypt failed:\ngot : % 02x\nwant: % 02x", ct[:], tst.cipher)
		}

		var p [16]byte

		clefiaDecrypt(p[:], ct[:], cl.rk[:], r)

		if !bytes.Equal(p[:], tst.plain) {
			t.Errorf("decrypt failed:\ngot : % 02x\nwant: % 02x", p[:], tst.plain)
		}

	}
}
